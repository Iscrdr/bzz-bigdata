package com.bzz.cloud.datastructure;

/**
 * @author ：Iscrdr
 * @description：希尔排序
 * @email ：624003618@qq.com
 * @date ：2021-01-18 21:27
 * @modified By：
 * @version: 1.0.0
 */
public class HillSort {


    /**
     * 希尔排序：[4,2,7,5,9,8,3,1,6,12,15],数组长度为11
     *
     * 跳跃式的分组,假设间隔为4,那么分4组,每组采用插入排序
     * [4,9,6],[2,8,12],[7,3,15],[5,1]
     * 每组采用插入排序,第一次排序得：[4,2,7,5,6,8,3,1,9,12,15]
     * 第二次排序：[4,2,7,5,6,8,3,1,9,12,15]
     * 第三次排序：[4,2,3,5,6,8,7,1,9,12,15]
     * 第四次排序：[4,2,3,1,6,8,7,5,9,12,15]
     *
     * [4,2,3,1,6,8,7,5,9,12,15]
     * 缩小间隔,设置间隔为3,分3组[4,1,7,12],[2,6,5,15],[3,8,9]
     * 每组采用插入排序,第一次排序得：[1,2,3,4,6,8,7,5,9,12,15]
     * 第二次排序得：[1,2,3,4,5,8,7,6,9,12,15]
     * 第三次排序：[1,2,3,4,5,8,7,6,9,12,15]
     *
     * [1,2,3,4,5,8,7,6,9,12,15]
     * 缩小间隔,设置为2,分5组[1,3,5,7,9,15],[2,4,8,6,12]
     * 第一次排序：[1,2,3,4,5,8,7,6,9,12,15]
     * 第二次排序：[1,2,3,4,5,6,7,8,9,12,15]
     *
     * 缩小间隔,设置为1时,在进行一次插入排序
     *
     * 增量序列{n/2,(n/2)/2...1}(希尔增量)，其最坏时间复杂度依然为O(n*n)，一些经过优化的增量序列如Hibbard经过复杂证明可使得最坏时间复杂度为O(n3/2)
     */
    public static void  sort(int [] arr){


        int  n = 1;
        while (n<arr.length/3){
            n = 3*n + 1;
        }
        /*
         * 间隔 k=  3*n + 1 ,三分之一
         * 折半 k= arr.length/2
         */

        //第一层循环为,间隔数
        for(int k= n;k > 0;k=(k-1)/3){
            for(int i=k;i<arr.length;i++){
                for(int j=i;j+1>k;j=j-k){
                    if(arr[j] < arr[j-k]){
                        int temp = arr[j];
                        arr[j] = arr[j-k];
                        arr[j-k] = temp;
                    }
                }
            }

        }
        UitlsSort.printArr(arr);

    }



}
